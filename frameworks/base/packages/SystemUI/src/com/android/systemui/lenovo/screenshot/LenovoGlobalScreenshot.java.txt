/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.systemui.lenovo.screenshot;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.app.Notification;
import android.app.Notification.BigPictureStyle;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.PointF;
import android.graphics.Bitmap.CompressFormat;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Environment;
import android.os.Process;
import android.provider.MediaStore;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.Surface;
import android.view.SurfaceControl;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.animation.Interpolator;
import android.widget.ImageView;
import android.widget.RemoteViews;

import com.android.systemui.R;
import com.android.systemui.lenovo.screenshot.ScreenShotUtil;
//shiyaru@wind-mobi.com 2018.5.9 start
import com.android.systemui.util.NotificationChannels;
//shiyaru@wind-mobi.com 2018.5.9 end

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
//shiyaru@wind-mobi.com modify add 2018.5.30 start
import com.android.systemui.scrollshot.ScrollShot;
import com.android.systemui.scrollshot.ScrollShotListener;
//shiyaru@wind-mobi.com modify add 2018.5.30 end
//shiyaru@wind-mobi.com add 2018.6.27 start
import android.os.Handler;
//shiyaru@wind-mobi.com add 2018.6.27 end
//shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 start
import com.android.systemui.scrollshot.Tools;
import android.app.WallpaperManager;
import android.graphics.Color;
//shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 end

/**
 * POD used in the AsyncTask which saves an image in the background.
 */
class SaveImageInBackgroundData {
    Context context;
    Bitmap image;
    Uri imageUri;
    Runnable finisher;
    int iconSize;
    int result;
    int previewWidth;
    int previewheight;
    Uri thumbnailUri;
    boolean showNotify;
    //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 start
    boolean isShare;
    //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 end

    void clearImage() {
        image = null;
        imageUri = null;
        iconSize = 0;
    }
    void clearContext() {
        context = null;
    }
}

/**
 * An AsyncTask that saves an image to the media store in the background.
 */
class SaveImageInBackgroundTask extends AsyncTask<SaveImageInBackgroundData, Void,
        SaveImageInBackgroundData> {
    private static final String TAG = "SaveImageInBackgroundTask";

    private static final String SCREENSHOTS_DIR_NAME = "Screenshots";
    private static final String SCREENSHOT_SHARE_SUBJECT_TEMPLATE = "Screenshot (%s)";

    private final int scaleRatio = 1;

    private final int mNotificationId;
    private final NotificationManager mNotificationManager;
    private final Notification.Builder mNotificationBuilder, mPublicNotificationBuilder;
    private final File mScreenshotDir;
    private final String mImageFileName;
    private final String mImageFilePath;
    private final long mImageTime;
    private final BigPictureStyle mNotificationStyle;
    private final int mImageWidth;
    private final int mImageHeight;
    private final boolean bShowNotify;
    //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 start
    private final boolean isShare;
    //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 end

    // WORKAROUND: We want the same notification across screenshots that we update so that we don't
    // spam a user's notification drawer.  However, we only show the ticker for the saving state
    // and if the ticker text is the same as the previous notification, then it will not show. So
    // for now, we just add and remove a space from the ticker text to trigger the animation when
    // necessary.
    private static boolean mTickerAddSpace;

    SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data,
            NotificationManager nManager, int nId) {
        Resources r = context.getResources();

        // Prepare all the output metadata
        mImageTime = System.currentTimeMillis();
        String imageDate = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss").format(new Date(mImageTime));

        /* Lenovo-sw ligr3 added 2014-09-05 begin, for adding 3 chars to screenshot filename */
        String timeStr = "" + mImageTime;
        String last3chars = timeStr.substring(timeStr.length() - 3);
        imageDate += "-" + last3chars;
        /* Lenovo-sw ligr3 added 2014-09-05 end, for adding 3 chars to screenshot filename */

        // Protentially for multi language supporting
        mImageFileName = String.format(r.getString(R.string.lenovo_screenshot_flie_name_template), imageDate);

        mScreenshotDir = new File(Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_PICTURES), SCREENSHOTS_DIR_NAME);
        mImageFilePath = new File(mScreenshotDir, mImageFileName).getAbsolutePath();

        bShowNotify = data.showNotify;
        //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 start
        isShare = data.isShare;
        //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 end
        // Create the large notification icon
        mImageWidth = data.image.getWidth();
        mImageHeight = data.image.getHeight();
        int iconSize = data.iconSize;
        int previewWidth = mImageWidth;
        int previewHeight = mImageHeight;

        final int shortSide = mImageWidth < mImageHeight ? mImageWidth : mImageHeight;
        Bitmap preview = Bitmap.createBitmap(previewWidth, previewHeight, data.image.getConfig());
        Canvas c = new Canvas(preview);
        Paint paint = new Paint();
/*
        ColorMatrix desat = new ColorMatrix();
        desat.setSaturation(0.25f);
        paint.setColorFilter(new ColorMatrixColorFilter(desat));
*/
        Matrix matrix = new Matrix();
        matrix.postTranslate((previewWidth - mImageWidth) / 2,
                            (previewHeight - mImageHeight) / 2);
        c.drawBitmap(data.image, matrix, paint);
//        c.drawColor(0x40FFFFFF);
        c.setBitmap(null);

        Bitmap croppedIcon = Bitmap.createScaledBitmap(preview, iconSize, iconSize, true);

        // Show the intermediate notification
        mTickerAddSpace = !mTickerAddSpace;
        mNotificationId = nId;
        mNotificationManager = nManager;

        /* Lenovo-sw ligr3 modified 2014-10-29 begin, for support whether show notification or not */
        if(!bShowNotify){
            mPublicNotificationBuilder = null;
            mNotificationStyle = null;
            mNotificationBuilder = null;
            return;
        }
        /* Lenovo-sw ligr3 modified 2014-10-29 end, for support whether show notification or not */

        final long now = System.currentTimeMillis();
        //shiyaru@wind-mobi.com Bug #12752 add screenshot notification 2018.5.9 start
        mNotificationBuilder = new Notification.Builder(context, NotificationChannels.SCREENSHOTS)
            .setTicker(r.getString(R.string.screenshot_saving_ticker)
                    + (mTickerAddSpace ? " " : ""))
            .setContentTitle(r.getString(R.string.screenshot_saving_title))
            .setContentText(r.getString(R.string.screenshot_saving_text))
            .setSmallIcon(R.drawable.stat_notify_image)
            .setWhen(now)
            .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
        //shiyaru@wind-mobi.com Bug #12752 add screenshot notification 2018.5.9 end
        mNotificationStyle = new Notification.BigPictureStyle()
                .bigPicture(preview);
        mNotificationBuilder.setStyle(mNotificationStyle);

        //shiyaru@wind-mobi.com Bug #12752 add screenshot notification 2018.5.9 start
        // For "public" situations we want to show all the same info but
        // omit the actual screenshot image.
        mPublicNotificationBuilder = new Notification.Builder(context, NotificationChannels.SCREENSHOTS)
            .setContentTitle(r.getString(R.string.screenshot_saving_title))
            .setContentText(r.getString(R.string.screenshot_saving_text))
            .setSmallIcon(R.drawable.stat_notify_image)
            .setCategory(Notification.CATEGORY_PROGRESS)
            .setWhen(now)
            .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
        //shiyaru@wind-mobi.com Bug #12752 add screenshot notification 2018.5.9 end
        mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());

        Notification n = mNotificationBuilder.build();
        n.flags |= Notification.FLAG_NO_CLEAR;
        mNotificationManager.notify(nId, n);

        // On the tablet, the large icon makes the notification appear as if it is clickable (and
        // on small devices, the large icon is not shown) so defer showing the large icon until
        // we compose the final post-save notification below.
        mNotificationBuilder.setLargeIcon(croppedIcon);
        mNotificationStyle.bigLargeIcon((Bitmap) null);
        // But we still don't set it for the expanded view, allowing the smallIcon to show here.
        /* Lenovo-sw ligr3 modified 2014-10-17 begin, for customizing notification */
        /* Lenovo-sw ligr3 modified 2014-10-17 end, for customizing notification */
    }

    @SuppressWarnings("deprecation")
    @Override
    protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params) {
        if (params.length != 1) return null;
        if (isCancelled()) {
            params[0].clearImage();
            params[0].clearContext();
            return null;
        }

        // By default, AsyncTask sets the worker thread to have background thread priority, so bump
        // it back up so that we save a little quicker.
        Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);

        Context context = params[0].context;
        Bitmap image = params[0].image;
        Resources r = context.getResources();

        try {
            // Create screenshot directory if it doesn't exist
            mScreenshotDir.mkdirs();

            // media provider uses seconds for DATE_MODIFIED and DATE_ADDED, but milliseconds
            // for DATE_TAKEN
            long dateSeconds = mImageTime / 1000;

            /** Lenovo-sw ligr3 modified 2014-12-11 begin, for saving the data use INSERT instead of UPDATE */
            FileOutputStream fos = new FileOutputStream(mImageFilePath);
            image.compress(Bitmap.CompressFormat.JPEG, 100, fos);//lenovo-sw wenglk1 modify 20130724, change PNG to jpeg for screenshot.
            fos.flush();
            fos.close();
            /** Lenovo-sw ligr3 modified 2014-12-11 end, for saving the data use INSERT instead of UPDATE */

            // Save the screenshot to the MediaStore
            ContentValues values = new ContentValues();
            ContentResolver resolver = context.getContentResolver();
            values.put(MediaStore.Images.ImageColumns.DATA, mImageFilePath);
            values.put(MediaStore.Images.ImageColumns.TITLE, mImageFileName);
            values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME, mImageFileName);
            values.put(MediaStore.Images.ImageColumns.DATE_TAKEN, mImageTime);
            values.put(MediaStore.Images.ImageColumns.DATE_ADDED, dateSeconds);
            values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED, dateSeconds);
            values.put(MediaStore.Images.ImageColumns.MIME_TYPE, "image/jpeg");
            values.put(MediaStore.Images.ImageColumns.WIDTH, mImageWidth);
            values.put(MediaStore.Images.ImageColumns.HEIGHT, mImageHeight);

            /** Lenovo-sw ligr3 modified 2014-12-11 begin, for saving the data use INSERT instead of UPDATE */
            values.put(MediaStore.Images.ImageColumns.SIZE, new File(mImageFilePath).length());

            Uri uri = null;
            Cursor c = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                    new String[]{MediaStore.Images.ImageColumns._ID},
                    MediaStore.Images.ImageColumns.DATA + "=?", new String[]{mImageFilePath}, null);
            if(c != null && c.moveToFirst()){
            	int recordID = c.getInt(0);
            	uri = Uri.withAppendedPath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, "" + recordID);
            	Log.d("lenovoscreenshot", "Record found, uri = " + uri);
            } else{
	            uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
	            Log.d("lenovoscreenshot", "Insert data, uri = " + uri);	// added by Lenovo-sw ligr3 at 2014-9-4
            }
            if(c != null){
            	c.close();
            }
            /** Lenovo-sw ligr3 modified 2014-12-11 end, for saving the data use INSERT instead of UPDATE */ 

            String subjectDate = DateFormat.getDateTimeInstance().format(new Date(mImageTime));
            String subject = String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE, subjectDate);
            Intent sharingIntent = new Intent(Intent.ACTION_SEND);
            sharingIntent.setType("image/jpeg");
            sharingIntent.putExtra(Intent.EXTRA_STREAM, uri);
            sharingIntent.putExtra(Intent.EXTRA_SUBJECT, subject);
            //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 start
            if (isShare) {
                Intent intent = Intent.createChooser(sharingIntent, null);
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivity(intent);
            }
            //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 start
            // Create a share action for the notification
            final PendingIntent callback = PendingIntent.getBroadcast(context, 0,
                    new Intent(context, LenovoGlobalScreenshot.TargetChosenReceiver.class)
                            .putExtra(LenovoGlobalScreenshot.CANCEL_ID, mNotificationId),
                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
            Intent chooserIntent = Intent.createChooser(sharingIntent, null, callback.getIntentSender());
            chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK
                    | Intent.FLAG_ACTIVITY_NEW_TASK);
            mNotificationBuilder.addAction(R.drawable.icon_bg_share_rest,
                    r.getString(com.android.internal.R.string.share),
                    PendingIntent.getActivity(context, 0, chooserIntent,
                            PendingIntent.FLAG_CANCEL_CURRENT));

            // Create a delete action for the notification
            final PendingIntent deleteAction = PendingIntent.getBroadcast(context,  0,
                    new Intent(context, LenovoGlobalScreenshot.DeleteScreenshotReceiver.class)
                            .putExtra(LenovoGlobalScreenshot.CANCEL_ID, mNotificationId)
                            .putExtra(LenovoGlobalScreenshot.SCREENSHOT_URI_ID, uri.toString()),
                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
            mNotificationBuilder.addAction(R.drawable.icon_bg_del_rest,
                    r.getString(com.android.internal.R.string.delete), deleteAction);

            /* Lenovo-sw ligr3 added 2015-03-06 begin, for create thunbmail */
            int maxWidth = params[0].context.getResources().getDimensionPixelSize(
                    R.dimen.screenshot_notify_pic_max_width);
            int maxHeight = params[0].context.getResources().getDimensionPixelSize(
                    R.dimen.screenshot_notify_pic_max_height);
            Bitmap thumbnail = ScreenShotUtil.createThumbnail(image, maxWidth, maxHeight);
            if(thumbnail != null && !thumbnail.isRecycled()){
                File file = new File(mScreenshotDir
                        , ScreenShotUtil.THUMBNAIL_FILE_NAME_LENOVO);
                if(file.exists()){
                    file.delete();
                }
                file.createNewFile();
                String thumbnailFilePath = file.getAbsolutePath();
                FileOutputStream fos2 = new FileOutputStream(thumbnailFilePath);
                thumbnail.compress(CompressFormat.JPEG, 100, fos2);
                fos2.flush();
                fos2.close();
                thumbnail.recycle();
                params[0].thumbnailUri = Uri.parse(thumbnailFilePath);
            } else{
                params[0].thumbnailUri = null;
            }

            /* Lenovo-sw ligr3 added 2015-03-06 end, for create thunbmail */

            OutputStream out = resolver.openOutputStream(uri);
            image.compress(Bitmap.CompressFormat.JPEG, 100, out);
            out.flush();
            out.close();

            // update file size in the database
            values.clear();
            values.put(MediaStore.Images.ImageColumns.SIZE, new File(mImageFilePath).length());
            resolver.update(uri, values, null, null);

            params[0].imageUri = uri;
            params[0].image = null;
            params[0].result = 0;
        } catch (Exception e) {
            // IOException/UnsupportedOperationException may be thrown if external storage is not
            // mounted
            params[0].clearImage();
            params[0].result = 1;
        }

        // Recycle the bitmap data
        if (image != null) {
            image.recycle();
        }

        return params[0];
    }

    @Override
    protected void onPostExecute(SaveImageInBackgroundData params) {
        if (isCancelled()) {
            params.finisher.run();
            params.clearImage();
            params.clearContext();
            return;
        }

        if (params.result > 0) {
            // Show a message that we've failed to save the image to disk
            LenovoGlobalScreenshot.notifyScreenshotError(params.context, mNotificationManager);
        } else {
        	/* Lenovo-sw ligr3 modified 2014-10-17 begin, for show notification switch */
        	if(bShowNotify){
	            // Show the final notification to indicate screenshot saved
	            Resources r = params.context.getResources();
	
	            // Create the intent to show the screenshot in gallery
	            Intent launchIntent = new Intent(Intent.ACTION_VIEW);
	            launchIntent.setDataAndType(params.imageUri, "image/jpeg");	// ligr3 modified, change to jpeg
	            launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	
	            final long now = System.currentTimeMillis();
	
	            mNotificationBuilder
	                .setContentTitle(r.getString(R.string.screenshot_saved_title))
	                .setContentText(r.getString(R.string.screenshot_saved_text))
	                .setContentIntent(PendingIntent.getActivity(params.context, 0, launchIntent, 0))
	                .setWhen(now)
	                .setAutoCancel(true)
	                /** Lenovo-xm lugl1, 2014-10-29 begin, modify internal resource.*/
	                //.setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
                    .setColor(r.getColor( com.android.internal.R.color.system_notification_accent_color));
	                /** Lenovo-xm lugl1, 2014-10-29 end, modify internal resource.*/
	            
	
	            // Update the text in the public version as well
	            mPublicNotificationBuilder
	                .setContentTitle(r.getString(R.string.screenshot_saved_title))
	                .setContentText(r.getString(R.string.screenshot_saved_text))
	                .setContentIntent(PendingIntent.getActivity(params.context, 0, launchIntent, 0))
	                .setWhen(now)
	                .setAutoCancel(true)
	                /** Lenovo-xm lugl1, 2014-10-29 begin, modify internal resource.*/
	                //.setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
                    .setColor(r.getColor( com.android.internal.R.color.system_notification_accent_color));
                    /** Lenovo-xm lugl1, 2014-10-29 end, modify internal resource.*/
	
	            mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());
	
	            Notification n = mNotificationBuilder.build();
	            n.flags &= ~Notification.FLAG_NO_CLEAR;
	            mNotificationManager.notify(mNotificationId, n);
	        }
	        /* Lenovo-sw ligr3 modified 2014-10-17 end, for show notification switch */
        }
        params.finisher.run();
        params.clearContext();
    }
}

        /**
         * An AsyncTask that deletes an image from the media store in the background.
         */
        class DeleteImageInBackgroundTask extends AsyncTask<Uri, Void, Void> {
            private static final String TAG = "DeleteImageInBackgroundTask";

            private Context mContext;

            DeleteImageInBackgroundTask(Context context) {
                mContext = context;
            }

            @Override
            protected Void doInBackground(Uri... params) {
                if (params.length != 1) return null;

                Uri screenshotUri = params[0];
                ContentResolver resolver = mContext.getContentResolver();
                resolver.delete(screenshotUri, null, null);
                return null;
            }
        }

/**
 * TODO:
 *   - Performance when over gl surfaces? Ie. Gallery
 *   - what do we say in the Toast? Which icon do we get if the user uses another
 *     type of gallery?
 */
class LenovoGlobalScreenshot {
    private static final String TAG = "LenovoGlobalScreenshot";

    static final String CANCEL_ID = "android:cancel_id";
    static final String SCREENSHOT_URI_ID = "android:screenshot_uri_id";

    private static final int SCREENSHOT_NOTIFICATION_ID = 789;
    private static final int SCREENSHOT_FLASH_TO_PEAK_DURATION = 130;
    private static final int SCREENSHOT_DROP_IN_DURATION = 430;
    private static final int SCREENSHOT_DROP_OUT_DELAY = 500;
    private static final int SCREENSHOT_DROP_OUT_DURATION = 430;
    private static final int SCREENSHOT_DROP_OUT_SCALE_DURATION = 370;
    private static final int SCREENSHOT_FAST_DROP_OUT_DURATION = 320;
    private static final float BACKGROUND_ALPHA = 0.5f;
    private static final float SCREENSHOT_SCALE = 1f;
    private static final float SCREENSHOT_DROP_IN_MIN_SCALE = SCREENSHOT_SCALE * 0.725f;
    private static final float SCREENSHOT_DROP_OUT_MIN_SCALE = SCREENSHOT_SCALE * 0.45f;
    private static final float SCREENSHOT_FAST_DROP_OUT_MIN_SCALE = SCREENSHOT_SCALE * 0.6f;
    private static final float SCREENSHOT_DROP_OUT_MIN_SCALE_OFFSET = 0f;
    private final int mPreviewWidth;
    private final int mPreviewHeight;

    private Context mContext;
    private WindowManager mWindowManager;
    private WindowManager.LayoutParams mWindowLayoutParams;
    private NotificationManager mNotificationManager;
    private Display mDisplay;
    private DisplayMetrics mDisplayMetrics;
    private Matrix mDisplayMatrix;

    private Bitmap mScreenBitmap;
    private View mScreenshotLayout;
    private ImageView mBackgroundView;
    private ImageView mScreenshotView;
    private ImageView mScreenshotFlash;

    private AnimatorSet mScreenshotAnimation;

    private int mNotificationIconSize;
    private float mBgPadding;
    private float mBgPaddingScale;

    private AsyncTask<SaveImageInBackgroundData, Void, SaveImageInBackgroundData> mSaveInBgTask;


    private boolean bShowNotifyGlobal;
    //shiyaru@wind-mobi.com modify scrollscreenshot bitmap preview 2018.5.30 start
    private ScrollShotListener mScrollShotListener;
    private boolean mIsScroll;
    //shiyaru@wind-mobi.com add 2018.6.27 start
    private Handler mHandler;
    //shiyaru@wind-mobi.com add 2018.6.27 end
    //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 start
    private WallpaperManager mWallpaperManager;
    //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 end

    /**
     * @param context everything needs a context :(
     */
    public LenovoGlobalScreenshot(Context context, boolean showNotfy, ScrollShotListener shotListener) {
    	bShowNotifyGlobal = showNotfy;
        mScrollShotListener = shotListener;
    	
        Resources r = context.getResources();
        mContext = context;
        LayoutInflater layoutInflater = (LayoutInflater)
                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

        // Inflate the screenshot layout
        mDisplayMatrix = new Matrix();
        mScreenshotLayout = layoutInflater.inflate(R.layout.global_screenshot, null);
        mBackgroundView = (ImageView) mScreenshotLayout.findViewById(R.id.global_screenshot_background);
        mScreenshotView = (ImageView) mScreenshotLayout.findViewById(R.id.global_screenshot);
        mScreenshotFlash = (ImageView) mScreenshotLayout.findViewById(R.id.global_screenshot_flash);
        mScreenshotLayout.setFocusable(true);
        mScreenshotLayout.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                // Intercept and ignore all touch events
                return true;
            }
        });

        // Setup the window that we are going to use
        mWindowLayoutParams = new WindowManager.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT, 0, 0,
                WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY,
                WindowManager.LayoutParams.FLAG_FULLSCREEN
                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
                    | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
                    | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED,
                PixelFormat.TRANSLUCENT);
        mWindowLayoutParams.setTitle("ScreenshotAnimation");
        mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        mNotificationManager =
            (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
        mDisplay = mWindowManager.getDefaultDisplay();
        mDisplayMetrics = new DisplayMetrics();
        mDisplay.getRealMetrics(mDisplayMetrics);

        // Get the various target sizes
        mNotificationIconSize =
            r.getDimensionPixelSize(android.R.dimen.notification_large_icon_height);

        // Scale has to account for both sides of the bg
        mBgPadding = (float) r.getDimensionPixelSize(R.dimen.global_screenshot_bg_padding);
        mBgPaddingScale = mBgPadding /  mDisplayMetrics.widthPixels;

        // determine the optimal preview size
        int panelWidth = 0;
        try {
            panelWidth = r.getDimensionPixelSize(R.dimen.notification_panel_width);
        } catch (Resources.NotFoundException e) {
        }
        if (panelWidth <= 0) {
            // includes notification_panel_width==match_parent (-1)
            panelWidth = mDisplayMetrics.widthPixels;
        }
        mPreviewWidth = panelWidth;
        mPreviewHeight = r.getDimensionPixelSize(R.dimen.notification_max_height);
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 start
        mWallpaperManager = (WallpaperManager) mContext.getSystemService(Context.WALLPAPER_SERVICE);
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 end
    }
    //shiyaru@wind-mobi.com modify scrollscreenshot bitmap preview 2018.5.30 end

    /**
     * Creates a new worker thread and saves the screenshot to the media store.
     */
    private void saveScreenshotInWorkerThread(Runnable finisher) {
        SaveImageInBackgroundData data = new SaveImageInBackgroundData();
        data.context = mContext;
        data.image = mScreenBitmap;
        data.iconSize = mNotificationIconSize;
        data.finisher = finisher;
        data.previewWidth = mPreviewWidth;
        data.previewheight = mPreviewHeight;
        data.showNotify = bShowNotifyGlobal;
        //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 start
        data.isShare = areaScreenshotView.isAutoShare();
        //shiyaru@wind-mobi.com Feature #10056 move scrollShot switch to screenshot 2018.4.25 start
        if (mSaveInBgTask != null) {
            mSaveInBgTask.cancel(false);
        }
        mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager,
                R.id.notification_screenshot).execute(data);
    }

    /**
     * @return the current display rotation in degrees
     */
    private float getDegreesForRotation(int value) {
        switch (value) {
        case Surface.ROTATION_90:
            return 360f - 90f;
        case Surface.ROTATION_180:
            return 360f - 180f;
        case Surface.ROTATION_270:
            return 360f - 270f;
        }
        return 0f;
    }

    /**Lenovo-sw liyg3 add 2014-01-28 begin, for area screenshot*/
    public AreaScreenshotView areaScreenshotView;
    /**Lenovo-sw liyg3 add 2014-01-28 end*/
    //shiyaru@wind-mobi.com modify scrollscreenshot bitmap preview 2018.5.30 start
    public void setIsScroll(boolean isScroll){
        this.mIsScroll = isScroll;
    }
    public boolean getIsScroll(){
        return mIsScroll;
    }

    void takeScrollScreenshot() {
        Log.d(TAG, "takeScrollScreenshot");
        ScrollShot.getInstance().handleScrollShot(mContext, mScrollShotListener);
    }
    //shiyaru@wind-mobi.com modify scrollscreenshot bitmap preview 2018.5.30 end
    /**
     * Takes a screenshot of the current display and shows an animation.
     */
    void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) {
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.9 start
        //shiyaru@wind-mobi.com modify scrollscreenshot bitmap preview 2018.5.30 start
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 start
        if (mIsScroll) {
            if (Tools.isHome(mContext) && !Tools.isTileHome(mContext)) {
                Bitmap mWallpaperBitmap = (mWallpaperManager.getOriginalBitmap() != null) ? mWallpaperManager.getOriginalBitmap() : mWallpaperManager.getBitmap();
                ScrollShot.getInstance().setWallpaper(mWallpaperBitmap);
                Bitmap tempBitmap = Bitmap.createBitmap(mDisplayMetrics.widthPixels,
                        mDisplayMetrics.heightPixels, Bitmap.Config.RGB_565);
                tempBitmap.eraseColor(Color.BLACK);
                Tools.setWallpaperBitmap(mWallpaperManager, tempBitmap);
                tempBitmap.recycle();
                mHandler = new Handler();
                mHandler.postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        takeScrollScreenshot();
                    }
                }, 1300);
                return;
            } else {
                if (!Tools.isHome(mContext)) {
                    takeScrollScreenshot();
                    return;
                }
            }
        }
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.12 end
        //shiyaru@wind-mobi.com modify scrollscreenshot bitmap preview 2018.5.30 end
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.9 end

        // We need to orient the screenshot correctly (and the Surface api seems to take screenshots
        // only in the natural orientation of the device :!)
        mDisplay.getRealMetrics(mDisplayMetrics);
        float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels};
        float degrees = getDegreesForRotation(mDisplay.getRotation());
        boolean requiresRotation = (degrees > 0);
        if (requiresRotation) {
            // Get the dimensions of the device in its native orientation
            mDisplayMatrix.reset();
            mDisplayMatrix.preRotate(-degrees);
            mDisplayMatrix.mapPoints(dims);
            dims[0] = Math.abs(dims[0]);
            dims[1] = Math.abs(dims[1]);
        }

        // Take the screenshot
        mScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]);
        if (mScreenBitmap == null) {
        	Log.e(TAG, "Get screen bitmap failed!!");
            notifyScreenshotError(mContext, mNotificationManager);
            finisher.run();
            return;
        }

        if (requiresRotation) {
            // Rotate the screenshot to the current orientation
            Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels,
                    mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);
            Canvas c = new Canvas(ss);
            c.translate(ss.getWidth() / 2, ss.getHeight() / 2);
            c.rotate(degrees);
            c.translate(-dims[0] / 2, -dims[1] / 2);
            c.drawBitmap(mScreenBitmap, 0, 0, null);
            c.setBitmap(null);
            // Recycle the previous bitmap
            mScreenBitmap.recycle();
            mScreenBitmap = ss;
        }

        /**add for area screenshot by liyg3 2014-01-28*/
        
        
        
        areaScreenshotView = AreaScreenshotView.getAreaScreenshotView(mContext);
        //shiyaru@wind-mobi.com fix TABFIVEP-3455 2018.7.17 start
        if (areaScreenshotView.getScreenBitmap() != null) {
            finisher.run();
            return;
        }
        //shiyaru@wind-mobi.com fix TABFIVEP-3455 2018.7.17 end
        Log.d("GlobalScreenshot:", "is navBarVisible ? : " + navBarVisible);
        areaScreenshotView.setScreenBitmap(mScreenBitmap);
        areaScreenshotView.addScreenshotView();
        saveValues(finisher, statusBarVisible, navBarVisible);
        /**add end */
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.9 start
        //shiyaru@wind-mobi.com fix TABFIVEP-2894 2018.6.27 start
        if (!mIsScroll) {
            mHandler = new Handler();
            mHandler.postDelayed(mRemoveAreaView, 2000);
        }
        //shiyaru@wind-mobi.com fix TABFIVEP-2894 2018.6.27 end
        //shiyaru@wind-mobi.com fix TABFIVEP-3148 2018.7.9 end
    }

    //shiyaru@wind-mobi.com fix TABFIVEP-3455 2018.7.17 start
    public Bitmap getScreenBitmap() {
        return this.mScreenBitmap;
    }
    //shiyaru@wind-mobi.com fix TABFIVEP-3455 2018.7.17 end

    //shiyaru@wind-mobi.com fix TABFIVEP-2894 2018.7.5 start
    private final Runnable mRemoveAreaView = new Runnable() {
        @Override
        public void run() {
            areaScreenshotView.sendHideShowNavigationBar(false);
            areaScreenshotView.removeScreenshotView();
            areaScreenshotView.doSaveScreenshotBitmap();
        }
    };
    public void removeCallback() {
        if (mHandler != null) {
            mHandler.removeCallbacks(mRemoveAreaView);
            mHandler = null;
        }
    }
    //shiyaru@wind-mobi.com fix TABFIVEP-2894 2018.7.5 end

    /**
     * 确定截图动作前，保存中间变量；
     */
    private Runnable finisher;
    private boolean statusBarVisible;
    private boolean navBarVisible;
    private void saveValues(final Runnable finisher, boolean statusBarVisible,
            boolean navBarVisible) {
    	this.finisher = finisher;
    	this.statusBarVisible = statusBarVisible;
    	this.navBarVisible = navBarVisible;
    }
    
    /**
     * 因截图之后需要对截屏进行裁剪，所以剥离出保存截图的代码
     */
	public void saveCropedScreenBitmap(Bitmap bm) {
		// 若截图有重新裁剪，则重新赋值
		if (mScreenBitmap != null && !mScreenBitmap.equals(bm)) {
			mScreenBitmap.recycle();
			mScreenBitmap = null;
		} else {
			Log.d("GlobalScreenshot:", "mScreenBitmap equals bm !");
		}
		mScreenBitmap = bm;
		mScreenBitmap.setHasAlpha(false);
		mScreenBitmap.prepareToDraw();

		// Start the post-screenshot animation
		startAnimation(finisher, mDisplayMetrics.widthPixels,
				mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible);
	}


    /**
     * Starts the animation after taking the screenshot
     */
    private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible,
            boolean navBarVisible) {
        // Add the view for the animation
        mScreenshotView.setImageBitmap(mScreenBitmap);
        mScreenshotLayout.requestFocus();

        // Setup the animation with the screenshot just taken
        if (mScreenshotAnimation != null) {
            mScreenshotAnimation.end();
            mScreenshotAnimation.removeAllListeners();
        }

        mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams);
        ValueAnimator screenshotDropInAnim = createScreenshotDropInAnimation();
        ValueAnimator screenshotFadeOutAnim = createScreenshotDropOutAnimation(w, h,
                statusBarVisible, navBarVisible);
        mScreenshotAnimation = new AnimatorSet();
        mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim);
        mScreenshotAnimation.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                // Save the screenshot once we have a bit of time now
            	/* 修改保存任务时间点，不再是动画结束时才去保存 */
//                saveScreenshotInWorkerThread(finisher);
                mWindowManager.removeView(mScreenshotLayout);
                //bug:A6000-1802 20161222 tupingwen modify begin
                mScreenshotAnimation = null;
                //bug:A6000-1802 20161222 tupingwen modify end

                // Clear any references to the bitmap
                mScreenBitmap = null;
                mScreenshotView.setImageBitmap(null);
            }
        });
        mScreenshotLayout.post(new Runnable() {
            @Override
            public void run() {
                // Play the shutter sound to notify that we've taken a screenshot
            	/* Lenovo-sw yangjb2 modify 2014-01-10 begin, for support profile*/
            	/* Lenovo-sw ligr3 delete 2014-12-11 begin, for disable sound when taking screenshot */
//            	if(mAudioManager.getRingerMode() != AudioManager.RINGER_MODE_VIBRATE && 
//            			mAudioManager.getRingerMode() != AudioManager.RINGER_MODE_SILENT) {
//            		mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
//            	}
            	/* Lenovo-sw ligr3 delete 2014-12-11 end, for disable sound when taking screenshot */
            	/* Lenovo-sw yangjb2 modify 2014-01-10 end*/
                mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
                mScreenshotView.buildLayer();
                mScreenshotAnimation.start();
            }
        });
    }
    private ValueAnimator createScreenshotDropInAnimation() {
        final float flashPeakDurationPct = ((float) (SCREENSHOT_FLASH_TO_PEAK_DURATION)
                / SCREENSHOT_DROP_IN_DURATION);
        final float flashDurationPct = 2f * flashPeakDurationPct;
        final Interpolator flashAlphaInterpolator = new Interpolator() {
            @Override
            public float getInterpolation(float x) {
                // Flash the flash view in and out quickly
                if (x <= flashDurationPct) {
                	return (float) Math.sin(Math.PI * (x / flashDurationPct)) * 0.2f;
                }
                return 0;
            }
        };
        final Interpolator scaleInterpolator = new Interpolator() {
            @Override
            public float getInterpolation(float x) {
                // We start scaling when the flash is at it's peak
                if (x < flashPeakDurationPct) {
                    return 0;
                }
                return (x - flashDurationPct) / (1f - flashDurationPct);
            }
        };
        ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
        anim.setDuration(SCREENSHOT_DROP_IN_DURATION);
        anim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                mBackgroundView.setAlpha(0f);
                mBackgroundView.setVisibility(View.VISIBLE);
                mScreenshotView.setAlpha(0f);
                mScreenshotView.setTranslationX(0f);
                mScreenshotView.setTranslationY(0f);
                mScreenshotView.setScaleX(SCREENSHOT_SCALE + mBgPaddingScale);
                mScreenshotView.setScaleY(SCREENSHOT_SCALE + mBgPaddingScale);
                mScreenshotView.setVisibility(View.VISIBLE);
                mScreenshotFlash.setAlpha(0f);
                mScreenshotFlash.setVisibility(View.VISIBLE);
            }
            @Override
            public void onAnimationEnd(android.animation.Animator animation) {
                mScreenshotFlash.setVisibility(View.GONE);
            }
        });
        anim.addUpdateListener(new AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                float t = (Float) animation.getAnimatedValue();
                float scaleT = (SCREENSHOT_SCALE + mBgPaddingScale)
                    - scaleInterpolator.getInterpolation(t)
                        * (SCREENSHOT_SCALE - SCREENSHOT_DROP_IN_MIN_SCALE);
                mBackgroundView.setAlpha(scaleInterpolator.getInterpolation(t) * BACKGROUND_ALPHA);
                mScreenshotView.setAlpha(t);
                mScreenshotView.setScaleX(scaleT);
                mScreenshotView.setScaleY(scaleT);
                mScreenshotFlash.setAlpha(flashAlphaInterpolator.getInterpolation(t));
            }
        });
        return anim;
    }
    private ValueAnimator createScreenshotDropOutAnimation(int w, int h, boolean statusBarVisible,
            boolean navBarVisible) {
        ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
        anim.setStartDelay(SCREENSHOT_DROP_OUT_DELAY);
        anim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
            	saveScreenshotInWorkerThread(finisher);
                mBackgroundView.setVisibility(View.GONE);
                mScreenshotView.setVisibility(View.GONE);
                mScreenshotView.setLayerType(View.LAYER_TYPE_NONE, null);
            }
        });

        if (!statusBarVisible || !navBarVisible) {
            // There is no status bar/nav bar, so just fade the screenshot away in place
            anim.setDuration(SCREENSHOT_FAST_DROP_OUT_DURATION);
            anim.addUpdateListener(new AnimatorUpdateListener() {
                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    float t = (Float) animation.getAnimatedValue();
                    float scaleT = (SCREENSHOT_DROP_IN_MIN_SCALE + mBgPaddingScale)
                            - t * (SCREENSHOT_DROP_IN_MIN_SCALE - SCREENSHOT_FAST_DROP_OUT_MIN_SCALE);
                    mBackgroundView.setAlpha((1f - t) * BACKGROUND_ALPHA);
                    mScreenshotView.setAlpha(1f - t);
                    mScreenshotView.setScaleX(scaleT);
                    mScreenshotView.setScaleY(scaleT);
                }
            });
        } else {
            // In the case where there is a status bar, animate to the origin of the bar (top-left)
            final float scaleDurationPct = (float) SCREENSHOT_DROP_OUT_SCALE_DURATION
                    / SCREENSHOT_DROP_OUT_DURATION;
            final Interpolator scaleInterpolator = new Interpolator() {
                @Override
                public float getInterpolation(float x) {
                    if (x < scaleDurationPct) {
                        // Decelerate, and scale the input accordingly
                        return (float) (1f - Math.pow(1f - (x / scaleDurationPct), 2f));
                    }
                    return 1f;
                }
            };

            // Determine the bounds of how to scale
            float halfScreenWidth = (w - 2f * mBgPadding) / 2f;
            float halfScreenHeight = (h - 2f * mBgPadding) / 2f;
            final float offsetPct = SCREENSHOT_DROP_OUT_MIN_SCALE_OFFSET;
            final PointF finalPos = new PointF(
                -halfScreenWidth + (SCREENSHOT_DROP_OUT_MIN_SCALE + offsetPct) * halfScreenWidth,
                -halfScreenHeight + (SCREENSHOT_DROP_OUT_MIN_SCALE + offsetPct) * halfScreenHeight);

            // Animate the screenshot to the status bar
            anim.setDuration(SCREENSHOT_DROP_OUT_DURATION);
            anim.addUpdateListener(new AnimatorUpdateListener() {
                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    float t = (Float) animation.getAnimatedValue();
                    float scaleT = (SCREENSHOT_DROP_IN_MIN_SCALE + mBgPaddingScale)
                        - scaleInterpolator.getInterpolation(t)
                            * (SCREENSHOT_DROP_IN_MIN_SCALE - SCREENSHOT_DROP_OUT_MIN_SCALE);
                    mBackgroundView.setAlpha((1f - t) * BACKGROUND_ALPHA);
                    mScreenshotView.setAlpha(1f - scaleInterpolator.getInterpolation(t));
                    mScreenshotView.setScaleX(scaleT);
                    mScreenshotView.setScaleY(scaleT);
                    mScreenshotView.setTranslationX(t * finalPos.x);
                    mScreenshotView.setTranslationY(t * finalPos.y);
                }
            });
        }
        return anim;
    }

    static void notifyScreenshotError(Context context, NotificationManager nManager) {
        Resources r = context.getResources();

        // Clear all existing notification, compose the new notification and show it
        Notification.Builder b = new Notification.Builder(context)
            .setTicker(r.getString(R.string.screenshot_failed_title))
            .setContentTitle(r.getString(R.string.screenshot_failed_title))
            .setContentText(r.getString(R.string.screenshot_failed_text))
            .setSmallIcon(R.drawable.stat_notify_image_error)
            .setWhen(System.currentTimeMillis())
            .setVisibility(Notification.VISIBILITY_PUBLIC) // ok to show outside lockscreen
            .setCategory(Notification.CATEGORY_ERROR)
            .setAutoCancel(true)
            /** Lenovo-xm lugl1, 2014-10-29 begin, modify internal resource.*/
            //.setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color));
            .setColor(context.getResources().getColor(R.color.internal_color_system_notification_accent_color));
            /** Lenovo-xm lugl1, 2014-10-29 end, modify internal resource.*/
        Notification n =
            new Notification.BigTextStyle(b)
                .bigText(r.getString(R.string.screenshot_failed_text))
                .build();
        nManager.notify(R.id.notification_screenshot, n);
    }
    
    /**
     * Lenovo-sw ligr3 added 2014-10-29, for setting if show notification
     * @param showNotify
     */
    public void setIfShowNotification(boolean showNotify){
    	bShowNotifyGlobal = showNotify;
    }

    /**
     * Removes the notification for a screenshot after a share target is chosen.
     */
    public static class TargetChosenReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (!intent.hasExtra(CANCEL_ID)) {
                return;
            }

            // Clear the notification
            final NotificationManager nm =
                    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
            final int id = intent.getIntExtra(CANCEL_ID, 0);
            nm.cancel(id);
        }
    }

    /**
     * Removes the last screenshot.
     */
    public static class DeleteScreenshotReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (!intent.hasExtra(CANCEL_ID) || !intent.hasExtra(SCREENSHOT_URI_ID)) {
                return;
            }

            // Clear the notification
            final NotificationManager nm =
                    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
            final int id = intent.getIntExtra(CANCEL_ID, 0);
            final Uri uri = Uri.parse(intent.getStringExtra(SCREENSHOT_URI_ID));
            nm.cancel(id);

            // And delete the image from the media store
            new DeleteImageInBackgroundTask(context).execute(uri);
        }
    }
}
