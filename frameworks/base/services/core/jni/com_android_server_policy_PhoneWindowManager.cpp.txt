/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//jiangbo@wind-mobi.com on 18.5.2 start
//add for the BT/Wifi address sync with NV
#include <jni.h>
#include <nativehelper/JNIHelp.h>

#include <cutils/properties.h>
#include <utils/Log.h>
#include <utils/misc.h>
#include <utils/AndroidThreads.h>

#include <unistd.h>
#include <stdlib.h>
#include "android_runtime/AndroidRuntime.h"
#include "nv.h"
//chusuxia@wind-mobi.com 20180503 start
#include "com_android_server_policy_PhoneWindowManager.h"
//chusuxia@wind-mobi.com 20180503 end
#ifndef LOG_TAG
#define LOG_TAG "NV-SYNC-JNI"
#endif
#ifndef LOGI
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#endif

#define MAC_ADDR_SIZE 6
#define MAC_ADDR_LENGTH 18
#define MAC_ADDR_ARRAY(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
#define MAC_ADDR_STRING "%02x:%02x:%02x:%02x:%02x:%02x"
//chusuxia@wind-mobi.com 20180503 start
static int SHOW_NV_LOG = 0;
//chusuxia@wind-mobi.com 20180503 end

namespace android {

jint NativeInit() {
    if (!Diag_LSM_Init(NULL)) {
        LOGI("Diag_LSM_Init() failed");
        return -1;
    }

    LOGI("Diag_LSM_Init successed.\n");

    register_callback();

    return 1;
}

void NativeDeInit() {
    Diag_LSM_DeInit();
}

void android_server_policy_PhoneWindowManager_syncModemNV(JNIEnv *env) {
    if (NativeInit() < 0) {
        return;
    }

    nv_items_enum_type nv_items[2] = {NV_WLAN_MAC_ADDRESS_I, NV_BD_ADDR_I};

    for (int nv_index = 0; nv_index < 2; nv_index++) {
        unsigned char tmp_nv[15] = {0};
        unsigned char mac_nv_addr[MAC_ADDR_SIZE];
        memset(tmp_nv, 0, sizeof(tmp_nv));
        memset(mac_nv_addr, 0, sizeof(mac_nv_addr));

        nv_items_enum_type nv_id = nv_items[nv_index];
        diag_nv_read(nv_id, tmp_nv, sizeof(tmp_nv));

        if (SHOW_NV_LOG) {
            for (int item_index = 0; item_index < 15; item_index++) {
                LOGI("syncModemNV tmp_nv[%d] = %02x ,%c", item_index, tmp_nv[item_index], tmp_nv[item_index]);
            }
        }

        int invalid = 0;
        int temp_index = 3;

        for (int item_index = 0; item_index < MAC_ADDR_SIZE; item_index++) {
            if (tmp_nv[temp_index] == '\0') {
                invalid++;
            } else {
                /*if (nv_index == 0) {
                    mac_nv_addr[item_index] = tmp_nv[item_index + 3];
                } else {
                    mac_nv_addr[MAC_ADDR_SIZE - 1 - item_index] = tmp_nv[item_index + 3];
                }*/
                if (tmp_nv[temp_index] == '}') {
                    LOGI("syncModemNV =");
                    if (tmp_nv[temp_index + 1] == '^') {
                        mac_nv_addr[item_index] = '~';
                        LOGI("syncModemNV char = 7E");
                    } else {
                        mac_nv_addr[item_index] = tmp_nv[temp_index];
                        LOGI("syncModemNV char = 7D");
                    }
                    temp_index++;
                } else {
                    mac_nv_addr[item_index] = tmp_nv[temp_index];
                }
            }
            temp_index++;
        }

        LOGI("syncModemNV nv_index = %d, invalid = %d", nv_index, invalid);

        if (invalid > 0) {
            //continue;
        }

        char mac_nv_str[MAC_ADDR_LENGTH];
        snprintf(mac_nv_str, MAC_ADDR_LENGTH, MAC_ADDR_STRING, MAC_ADDR_ARRAY(mac_nv_addr));
        LOGI("syncModemNV mac_nv_str : %s", mac_nv_str);

        if (nv_index == 0) {
            property_set("persist.security.wcnss.nv", mac_nv_str);
        } else {
            property_set("persist.service.bdroid.bdaddr", mac_nv_str);
        }
    }
    
    NativeDeInit();
}

//chusuxia@wind-mobi.com 20180503 start
jstring CharTojstring(JNIEnv* env, const char* str) {
    jsize len = strlen(str);
    jclass clsstring = env->FindClass("java/lang/String");
    jstring strencode = env->NewStringUTF("utf-8");
    jmethodID mid = env->GetMethodID(clsstring, "<init>",
            "([BLjava/lang/String;)V");
    jbyteArray barr = env->NewByteArray(len);
    env->SetByteArrayRegion(barr, 0, len, (jbyte*) str);
    return (jstring) env->NewObject(clsstring, mid, barr, strencode);
}

jstring android_server_policy_PhoneWindowManager_readFactoryNV(JNIEnv *env) {
    if (SHOW_NV_LOG) {
        LOGI("android_native_read_FactoryNV");
    }
    if (NativeInit() < 0) {
        return NULL;
    }
    unsigned char tmp[131] = { 0 };
    unsigned char after[128] = { 0 };
    memset(tmp, 0, sizeof(tmp));
    memset(after, 0, sizeof(after));
    /* nvId is for nv position , here is 02497 -> NV_FACTORY_DATA_1_I ,this define in vendor/qcom/proprietary/fastmmi/ */
    nv_items_enum_type nvId = NV_FACTORY_DATA_1_I;
    diag_nv_read(nvId, tmp, sizeof(tmp));

    for (unsigned int m = 0; m < (sizeof(tmp)-3); m++) {
        //add for flag exception log
        LOGI("android_native_read_FactoryNV tmp[%d] = %02x ,%c\n", m, tmp[m],tmp[m]);
        if (tmp[m + 3] == '\0') {
            after[m] = ' ';
        } else {
            after[m] = tmp[m + 3];
        }
    }
    //after[sizeof(tmp) - 3] = '\0';
    const char* p = (const char*) (char*) after;
    if (SHOW_NV_LOG) {
        for (unsigned int i = 0; i < sizeof(after); i++) {
            LOGI("android_native_read_FactoryNV p[%d] = %02x\n", i, p[i]);
        }
    }

    jstring flag_string = CharTojstring(env, p);
    return flag_string;
}
//chusuxia@wind-mobi.com 20180503 end



/*
 * JNI registration.
 */
static const JNINativeMethod gMethods[] = {
    { "syncModemNV","()V", (void*)android_server_policy_PhoneWindowManager_syncModemNV },
    //chusuxia@wind-mobi.com 201805003 start  
    { "readFactoryNV","()Ljava/lang/String;", (void*)android_server_policy_PhoneWindowManager_readFactoryNV },
    //chusuxia@wind-mobi.com 201805003 end
};

int register_android_server_policy_PhoneWindowManager(JNIEnv* env)
{
    return jniRegisterNativeMethods(env, "com/android/server/policy/PhoneWindowManager",
            gMethods, NELEM(gMethods));
}

}; // namespace android
//jiangbo@wind-mobi.com on 18.5.2 end
