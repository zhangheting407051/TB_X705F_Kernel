/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file was modified by Dolby Laboratories, Inc. The portions of the
 * code that are surrounded by "DOLBY..." are copyrighted and
 * licensed separately, as follows:
 *
 *  (C) 2017 Dolby Laboratories, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_NDEBUG 0
#define LOG_TAG "Ac4Utils"
#include <utils/Log.h>
#include <android/log.h>

#include "include/Ac4Utils.h"

#include <media/stagefright/foundation/ABitReader.h>
#include <media/stagefright/foundation/ADebug.h>
#include <media/stagefright/foundation/hexdump.h>
#include <media/stagefright/MediaDefs.h>
#include <media/stagefright/MediaErrors.h>
#include <media/stagefright/MetaData.h>
#include <utils/misc.h>

namespace android {

// This AC-4 Parser is based on
// -- ETSI TS 103 190-1 V1.2.1 (2015-06)
// -- ETSI TS 103 190-2 V1.1.1 (2015-09)

static int32_t fs_index = 1;    // Default is 48kHz
static int32_t frame_rate_factor = 1;

static int32_t readVariableBits(ABitReader &bits, int32_t nbits) {
    int32_t value = 0;
    int32_t more_bits = 1;

    while (more_bits) {
        value += bits.getBits(nbits);
        more_bits = bits.getBits(1);
        if (!more_bits)
            break;
        value++;
        value <<= nbits;
    }
    return value;
}

static void oamd_substream_info() {
    // TODO
}

static void ac4_substream_info_ajoc() {
    // TODO
}

static void ac4_substream_info_obj() {
    // TODO
}

static void presentation_config_ext_info() {
    // TODO
}

static void parseAc4ContentType(ABitReader &bits) {
    bits.skipBits(3);   // content_classifier
    int32_t b_language_indicator = bits.getBits(1);
    if (b_language_indicator) {
        int32_t b_serialized_language_tag = bits.getBits(1);
        if (b_serialized_language_tag) {
            bits.skipBits(1);       // b_start_tag
            bits.skipBits(16);      // language_tag_chunk
        } else {
            int32_t n_language_tag_bytes = bits.getBits(6);
            for (int32_t i = 0; i < n_language_tag_bytes; i++) {
                bits.skipBits(8);   // language_tag_bytes
            }
        }
    }
}

static int32_t parseAc4SubstreamInfo(ABitReader &bits) {

    int32_t channel_count = -1;
    int32_t channel_mode  = bits.getBits(1);     // 1 bit
    if (channel_mode == 0x1) {
        channel_mode = (channel_mode << 1) + bits.getBits(1); // 2 bits
        if (channel_mode == 0x3) {
            channel_mode = (channel_mode << 2) + bits.getBits(2); // 4 bits
            if (channel_mode == 0xf) {
                channel_mode = (channel_mode << 3) + bits.getBits(3); // 7 bits
            }
        }
    }

    if (channel_mode == 0x7f) {
        channel_mode += readVariableBits(bits, 2);
    }

    switch (channel_mode) {
        case 0x0:   channel_count = 1;  break; /* mono */
        case 0x2:   channel_count = 2;  break; /* stereo */
        case 0xc:   channel_count = 3;  break; /* 3.0 */
        case 0xd:   channel_count = 5;  break; /* 5.0 */
        case 0xe:   channel_count = 6;  break; /* 5.1 */
        case 0x78:  channel_count = 7;  break; /* 7.0 */
        case 0x79:  channel_count = 8;  break; /* 7.1 */
        case 0x7a:  channel_count = 7;  break; /* 7.0 */
        case 0x7b:  channel_count = 8;  break; /* 7.1 */
        case 0x7c:  channel_count = 7;  break; /* 7.0 */
        case 0x7d:  channel_count = 8;  break; /* 7.1 */
        default:
            ALOGE("Incorrect AC-4 channel mode!");
            break;
    }

    if (fs_index == 1) {    /* 48 kHz */
        int32_t b_sf_multiplier = bits.getBits(1);
        if (b_sf_multiplier) {
            bits.skipBits(1);    // sf_multiplier
        }
    }
    int32_t b_bitrate_info = bits.getBits(1);
    if (b_bitrate_info) {
        int32_t bitrate_indicator = bits.getBits(3);
        if ((bitrate_indicator & 0x1) == 1) {
            bitrate_indicator = (bitrate_indicator << 2) + bits.getBits(2);
        }
    }

    if (channel_mode == 0x7a || channel_mode == 0x7b || channel_mode == 0x7c ||
        channel_mode == 0x7d) {
        bits.skipBits(1);  // add_ch_base
    }
    int32_t b_content_type = bits.getBits(1);
    if (b_content_type) {
        parseAc4ContentType(bits);
    }
    for (int32_t i = 0; i < frame_rate_factor; i++) {
        bits.skipBits(1); // b_iframe
    }

    int32_t substream_index = bits.getBits(2);
    if (substream_index == 3) {
        substream_index += readVariableBits(bits, 2);
    }

    return channel_count;
}

static int32_t parseAc4SubstreamInfoChan(ABitReader &bits, int32_t b_substreams_present) {

    int32_t channel_count = -1;
    int32_t channel_mode  = bits.getBits(1);     // 1 bit
    if (channel_mode == 0x1) {
        channel_mode = (channel_mode << 1) + bits.getBits(1); // 2 bits
        if (channel_mode == 0x3) {
            channel_mode = (channel_mode << 2) + bits.getBits(2); // 4 bits
            if (channel_mode == 0xf) {
                channel_mode = (channel_mode << 3) + bits.getBits(3); // 7 bits
                if (channel_mode == 0x7e) {
                    channel_mode = (channel_mode << 1) + bits.getBits(1); // 8 bits
                } else if (channel_mode == 0x7f) {
                    channel_mode = (channel_mode << 2) + bits.getBits(2); // 9 bits
                }
            }
        }
    }

    if (channel_mode == 0x1ff) {
        channel_mode += readVariableBits(bits, 2);
    }

    switch (channel_mode) {
        case 0x0:   channel_count = 1;  break; /* mono */
        case 0x2:   channel_count = 2;  break; /* stereo */
        case 0xc:   channel_count = 3;  break; /* 3.0 */
        case 0xd:   channel_count = 5;  break; /* 5.0 */
        case 0xe:   channel_count = 6;  break; /* 5.1 */
        case 0x78:  channel_count = 7;  break; /* 7.0 */
        case 0x79:  channel_count = 8;  break; /* 7.1 */
        case 0x7a:  channel_count = 7;  break; /* 7.0 or IMS All */
        case 0x7b:  channel_count = 8;  break; /* 7.1 or IMS Atmos */
        case 0x7c:  channel_count = 7;  break; /* 7.0 */
        case 0x7d:  channel_count = 8;  break; /* 7.1 */
        case 0xfc:  channel_count = 11; break; /* 7.0.4 */
        case 0xfd:  channel_count = 12; break; /* 7.1.4 */
        case 0x1fc: channel_count = 13; break; /* 9.0.4 */
        case 0x1fd: channel_count = 14; break; /* 9.1.4 */
        case 0x1fe: channel_count = 24; break; /* 22.2 */
        default:
            ALOGE("Incorrect AC-4 channel mode!");
            break;
    }

    if (channel_mode == 0xfc || channel_mode == 0xfd || channel_mode == 0x1fc ||
        channel_mode == 0x1fd) {
        bits.skipBits(1); // b_4_back_channels_present
        bits.skipBits(1); // b_centre_present
        bits.skipBits(2); // top_channels_present
    }

    if (fs_index == 1) {
        int32_t b_sf_multiplier = bits.getBits(1);
        if (b_sf_multiplier) {
            bits.skipBits(1); // sf_multiplier
        }
    }
    int32_t b_bitrate_info = bits.getBits(1);
    if (b_bitrate_info) {
        int32_t bitrate_indicator = bits.getBits(3);
        if ((bitrate_indicator & 0x1) == 1) {
            bitrate_indicator = (bitrate_indicator << 2) + bits.getBits(2);
        }
    }
    if (channel_mode == 0x7a || channel_mode == 0x7b || channel_mode == 0x7c ||
        channel_mode == 0x7d) {
        bits.skipBits(1); // add_ch_base
    }
    for (int32_t i = 0; i < frame_rate_factor; i++) {   // static global variable
        bits.skipBits(1);    // b_audio_ndot
    }
    if (b_substreams_present == 1) {
        int32_t substream_index = bits.getBits(2);
        if (substream_index == 3) {
            substream_index += readVariableBits(bits, 2);
        }
    }

    return channel_count;
}

static void parseAc4FrameRateMultiplyInfo(ABitReader &bits, int32_t frame_rate_index) {

    int32_t b_multiplier = 0;
    int32_t multiplier_bit = 0;
    frame_rate_factor = 1;
    switch (frame_rate_index) {
        case 2:
        case 3:
        case 4:
            b_multiplier = bits.getBits(1);
            if (b_multiplier) {
                multiplier_bit = bits.getBits(1);
                if (multiplier_bit) {
                    frame_rate_factor = 4;
                } else {   // multiplier_bit == 0
                    frame_rate_factor = 2;
                }
            }
            break;
        case 0:
        case 1:
        case 7:
        case 8:
        case 9:
            b_multiplier = bits.getBits(1);
            if (b_multiplier) {
                frame_rate_factor = 2;
            }
            break;
        default:
            break;
    }
}

static void parseAc4FrameRateFractionsInfo(ABitReader &bits, int32_t frame_rate_index) {

    int32_t frame_rate_fraction = 1;
    int32_t b_frame_rate_fraction;
    switch (frame_rate_index) {
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
            if (frame_rate_factor == 1) {
                b_frame_rate_fraction = bits.getBits(1);
                if (b_frame_rate_fraction == 1) {
                    frame_rate_fraction = 2;
                }
            }
            break;
        case 10:
        case 11:
        case 12:
            b_frame_rate_fraction = bits.getBits(1);
            if (b_frame_rate_fraction == 1) {
                int32_t b_frame_rate_fraction_is_4 = bits.getBits(1);
                if (b_frame_rate_fraction_is_4 == 1) {
                    frame_rate_fraction = 4;
                } else {
                    frame_rate_fraction = 2;
                }
            }
            break;
        default:
            break;
    }
}

static void parseAc4EmdfInfo(ABitReader &bits) {

    uint32_t protection_length_primary, protection_length_secondary;
    int32_t LengthTable[] = { 0, 8, 32, 128 };

    int32_t emdf_version = bits.getBits(2);
    if (emdf_version == 3) {
        emdf_version += readVariableBits(bits, 2);
    }

    int32_t key_id = bits.getBits(3);
    if (key_id == 7) {
        key_id += readVariableBits(bits, 3);
    }

    int32_t b_emdf_payloads_substream_info = bits.getBits(1);
    if (b_emdf_payloads_substream_info) {
        // emdf_payloads_substream_info()
        int32_t substream_index = bits.getBits(2);
        if (substream_index == 3) {
            substream_index += readVariableBits(bits, 2);
        }
    }

    // emdf_protection()
    protection_length_primary   = bits.getBits(2);
    protection_length_secondary = bits.getBits(2);

    for (int32_t i = 0; i < LengthTable[protection_length_primary] / 8; i++) {
        bits.skipBits(8);    // protection_bits_primary
    }

    for (int32_t i = 0; i < LengthTable[protection_length_secondary] / 8; i++) {
        bits.skipBits(8);    // protection_bits_secondary
    }
}

static void parseAc4HsfExtSubstreamInfo(ABitReader &bits, int32_t b_substreams_present) {
    if (b_substreams_present == 1) {
        int32_t substream_index = bits.getBits(2);
        if (substream_index == 3) {
            substream_index += readVariableBits(bits, 2);
        }
    }
}

static int32_t parseAc4SubstreamGroupInfo(ABitReader &bits, int32_t &chanCount,
                int32_t bitstream_version) {

    int32_t result = 0;
    int32_t n_lf_substreams = 0;

    int32_t b_substreams_present = bits.getBits(1);
    int32_t b_hsf_ext = bits.getBits(1);
    int32_t b_single_substream = bits.getBits(1);

    if (b_single_substream) {
        n_lf_substreams = 1;
    } else {
        int32_t n_lf_substreams_minus2 = bits.getBits(2);
        n_lf_substreams = n_lf_substreams_minus2 + 2;
        if (n_lf_substreams == 5) {
            n_lf_substreams += readVariableBits(bits, 2);
        }
    }

    int32_t b_channel_coded = bits.getBits(1);
    if (b_channel_coded) {
        for (int32_t sus = 0; sus < n_lf_substreams; sus++) {
            int32_t sus_ver = 0;
            if (bitstream_version == 1) {
                sus_ver = bits.getBits(1);
            } else {
                sus_ver = 1;
            }

            chanCount = parseAc4SubstreamInfoChan(bits, b_substreams_present);
            if (chanCount < 0) {
                result = -1;
            }
            if (b_hsf_ext) {
                parseAc4HsfExtSubstreamInfo(bits, b_substreams_present);
            }
        }
    } else {
        int32_t b_oamd_substream = bits.getBits(1);
        if (b_oamd_substream) {
            oamd_substream_info();
        }
        for (int32_t sus = 0; sus < n_lf_substreams; sus++) {
            int32_t b_ajoc = bits.getBits(1);
            if (b_ajoc) {
                ac4_substream_info_ajoc();
                if (b_hsf_ext) {
                    parseAc4HsfExtSubstreamInfo(bits, b_substreams_present);
                }
            } else {
                ac4_substream_info_obj();
                if (b_hsf_ext) {
                    parseAc4HsfExtSubstreamInfo(bits, b_substreams_present);
                }
            }
        }
        ALOGE("It is NOT supported by now, as it deals with OAMD and JOC!!!");
        result = -1;
    }

    int32_t b_content_type = bits.getBits(1);
    if (b_content_type) {
        parseAc4ContentType(bits);
    }

    return result;
}

static int32_t parseAc4SgiSpecifier(ABitReader &bits, int32_t &chanCount,
                int32_t bitstream_version){

    int32_t result = 0;
    int32_t group_index = 0;

    if (bitstream_version == 1) {
        int32_t channel_count = -1;
        result = parseAc4SubstreamGroupInfo(bits, channel_count, bitstream_version);
        if (channel_count < 0) {
            chanCount = channel_count;
            result = -1;
        } else {
            chanCount = channel_count;
        }
    } else {
        group_index = bits.getBits(3);
        if (group_index == 7) {
            group_index += readVariableBits(bits, 2);
        }
    }
    return result;
}

static int32_t parseAc4PresentationV1Info(ABitReader &bits, int32_t &chanCount,
                int32_t bitstream_version, int32_t frame_rate_index) {

    int32_t presentation_config = 0;
    int32_t result = 0;
    int32_t b_add_emdf_substreams = 0;

    int32_t b_single_substream_group = bits.getBits(1); // b_single_substream_group
    if (b_single_substream_group != 1) {
        presentation_config = bits.getBits(3);
        if (presentation_config == 7) {
            presentation_config += readVariableBits(bits,2);
        }
    }
    int32_t presentation_version = 0;
    if (bitstream_version != 1) {
        presentation_version = 0;
        while (bits.getBits(1) == 1) {
            presentation_version++;
        }
    }

    if (b_single_substream_group != 1 && presentation_config == 6) {
        b_add_emdf_substreams = 1;
    } else {
        if (bitstream_version != 1) {
            bits.skipBits(3);   // mdcompat
        }

        int32_t b_presentation_group_index = bits.getBits(1);
        if (b_presentation_group_index) {
            readVariableBits(bits, 2); // presentation_group_index
        }

        // frame_rate_multiply_info
        parseAc4FrameRateMultiplyInfo(bits, frame_rate_index);

        // frame_rate_fractions_info
        parseAc4FrameRateFractionsInfo(bits, frame_rate_index);

        // emd_info
        parseAc4EmdfInfo(bits);

        int32_t n_substream_groups = 0;
        int32_t b_presentation_filter = bits.getBits(1);

        if( b_presentation_filter) {
            bits.skipBits(1); // b_enable_presentation
        }

        if (b_single_substream_group == 1) {
            int32_t channel_count = -1;
            result = parseAc4SgiSpecifier(bits, channel_count, bitstream_version);
            if (result < 0) {
                return result;
            } else {
                chanCount = channel_count;
                if (chanCount > 0) {
                    return result;
                }
            }
            n_substream_groups = 1;
        } else {
            bits.skipBits(1);  // b_multi_pid
            int32_t channel_count = -1;
            int32_t n_substream_groups_minus2 = 0;
            if (presentation_config >= 0 && presentation_config <= 4) {
                result = parseAc4SgiSpecifier(bits, channel_count, bitstream_version);
                if (result < 0) {
                    return result;
                } else {
                    chanCount = channel_count;
                    if (chanCount > 0) {
                        return result;
                    }
                }
                result = parseAc4SgiSpecifier(bits, channel_count, bitstream_version);
                if (result < 0) {
                    return result;
                } else {
                    chanCount = channel_count;
                    if (chanCount > 0) {
                        return result;
                    }
                }
                if (presentation_config == 3 || presentation_config == 4) {
                    result = parseAc4SgiSpecifier(bits, channel_count, bitstream_version);
                    if (result < 0) {
                        return result;
                    } else {
                        chanCount = channel_count;
                        if (chanCount > 0) {
                            return result;
                        }
                    }
                }
            }

            switch (presentation_config) {
                case 0:
                    n_substream_groups = 2;
                    break;
                case 1:
                    n_substream_groups = 1;
                    break;
                case 2:
                    n_substream_groups = 2;
                    break;
                case 3:
                    n_substream_groups = 3;
                    break;
                case 4:
                    n_substream_groups = 2;
                    break;
                case 5:
                    n_substream_groups_minus2 = bits.getBits(2);
                    n_substream_groups = n_substream_groups_minus2 + 2;
                    if (n_substream_groups == 5) {
                        n_substream_groups += readVariableBits(bits, 2);
                    }
                    for (int32_t sg = 0; sg < n_substream_groups; sg++) {
                        result = parseAc4SgiSpecifier(bits, channel_count, bitstream_version);
                        if (result < 0) {
                            return result;
                        } else {
                            chanCount = channel_count;
                            if (chanCount > 0) {
                                return result;
                            }
                        }
                    }
                    break;
                default:
                    presentation_config_ext_info();
                    ALOGE("presentation_config %d is not supported now !!!",
                            presentation_config);
                    break;
            }
        }
        bits.skipBits(1); // b_pre_virtualized
        b_add_emdf_substreams = bits.getBits(1);

        // ac4_presentation_substream_info
        bits.skipBits(1); // b_alternative
        bits.skipBits(1); // b_pres_ndot
        int32_t substrm_index = bits.getBits(2);
        if (substrm_index == 3) {
            substrm_index += readVariableBits(bits, 2);
        }
    }

    if (b_add_emdf_substreams) {
        int32_t n_add_emdf_substreams = bits.getBits(2);
        if (n_add_emdf_substreams == 0) {
            n_add_emdf_substreams = readVariableBits(bits, 2) + 4;
        }

        for (int32_t i = 0; i < n_add_emdf_substreams; i++) {
            parseAc4EmdfInfo(bits);
        }
    }

    return result;
}

static int32_t parseAc4PresentationInfo(ABitReader &bits, int32_t &chanCount,
                int32_t frame_rate_index) {

    int32_t result = 0;
    int32_t presentation_config = 0;
    int32_t presentation_version = 0;
    int32_t b_add_emdf_substreams = 0;

    int32_t b_single_substream = bits.getBits(1);
    if (b_single_substream != 1) {
        presentation_config = bits.getBits(3);
        if (presentation_config == 7) {
            presentation_config += readVariableBits(bits, 2);
        }
    }
    for (presentation_version = 0; bits.getBits(1) == 1; presentation_version++)
        ;

    if (b_single_substream != 1 && presentation_config == 6) {
        b_add_emdf_substreams = 1;
    } else {
        bits.skipBits(3);   // mdcompat

        int32_t b_presentation_group_index = bits.getBits(1);   // b_presentation_group_index
        if (b_presentation_group_index) {
            readVariableBits(bits, 2); // presentation_group_index
        }

        // frame_rate_multiply_info
        parseAc4FrameRateMultiplyInfo(bits, frame_rate_index);

        // emd_info
        parseAc4EmdfInfo(bits);

        int32_t channel_count = -1;
        if (b_single_substream == 1) {
            channel_count = parseAc4SubstreamInfo(bits);
        } else {
            int32_t b_hsf_ext = bits.getBits(1);
            switch (presentation_config) {
                case 0: /* Music and Effects (M+E) + Dialog */
                    channel_count = parseAc4SubstreamInfo(bits);
                    if (b_hsf_ext == 1) {
                        parseAc4HsfExtSubstreamInfo(bits, 1);
                    }
                    parseAc4SubstreamInfo(bits);
                    break;
                case 1: /* Main + DE */
                    channel_count = parseAc4SubstreamInfo(bits);
                    if (b_hsf_ext == 1) {
                        parseAc4HsfExtSubstreamInfo(bits, 1);
                    }
                    parseAc4SubstreamInfo(bits);
                    break;
                case 2: /* Main + Associate */
                    channel_count = parseAc4SubstreamInfo(bits);
                    if (b_hsf_ext == 1) {
                        parseAc4HsfExtSubstreamInfo(bits, 1);
                    }
                    parseAc4SubstreamInfo(bits);
                    break;
                case 3: /* Music and Effects (M+E) + Dialog + Associate */
                    channel_count = parseAc4SubstreamInfo(bits);
                    if (b_hsf_ext == 1) {
                        parseAc4HsfExtSubstreamInfo(bits, 1);
                    }
                    parseAc4SubstreamInfo(bits);
                    parseAc4SubstreamInfo(bits);
                    break;
                case 4: /* Main + DE Associate */
                    channel_count = parseAc4SubstreamInfo(bits);
                    if (b_hsf_ext == 1) {
                        parseAc4HsfExtSubstreamInfo(bits, 1);
                    }
                    parseAc4SubstreamInfo(bits);
                    parseAc4SubstreamInfo(bits);
                    break;
                case 5: /* Main + HSF ext */
                    channel_count = parseAc4SubstreamInfo(bits);
                    if (b_hsf_ext == 1) {
                        parseAc4HsfExtSubstreamInfo(bits, 1);
                    }
                    break;
                default:
                    break;
            }
        }
        if (channel_count > 0) {
            chanCount = channel_count;
        } else {
            return -1;
        }
    }
    return result;
}

size_t parseAc4FrameSize(const uint8_t *ptr) {
// ETSI TS 103 190-2 V1.1.1 (2015-09), Annex C
    size_t frame_size = 0;
    size_t header_size = 0;

    frame_size = ((size_t)(ptr[2] & 0xff) << 8) | ((size_t)ptr[3] & 0xff);

    if (frame_size == 0xffff) {
        frame_size = (size_t)(ptr[6] & 0xff) | ((size_t)(ptr[5] & 0xff) << 8) |
        ((size_t)(ptr[4] & 0xff) << 16);
        header_size = 7;    // 2--sync words, 2--frame size, 3--frame size
    } else {
        header_size = 4;    // 2--sync words, 2--frame size
    }

    frame_size += header_size;

    if (ptr[1] & 0x01) {
        frame_size += 2;
    }

    return frame_size;
}

int32_t parseAc4StreamInfo(const uint8_t *ptr, size_t size, int32_t *chanCount,
                int32_t *smplRate) {

    int32_t result  = 0;
    ABitReader bits(ptr, size);
    int32_t sync_word = bits.getBits(16);
    if ((sync_word != 0xAC40) && (sync_word != 0xAC41)) {
        ALOGE("Invalid syncword in AC4 header");
        return -1;
    }

    uint32_t framesize = bits.getBits(16);
    if (framesize == 0xffff) {
        bits.skipBits(24);
    }

    int32_t bitstream_version = bits.getBits(2);    // 4.2.3.1
    if (bitstream_version == 3) {
        bitstream_version += readVariableBits(bits, 2);
    }

    bits.skipBits(10); // Sequence Counter

    int32_t b_wait_frames = bits.getBits(1);
    if (b_wait_frames) {
        int32_t wait_frames = bits.getBits(3);
        if (wait_frames > 0) {
            bits.skipBits(2); // reserved;
        }
    }

    fs_index = bits.getBits(1); // static global variable
    if (fs_index == 0) {
        *smplRate = 44100;
    } else {
        *smplRate = 48000;
    }

    int32_t frame_rate_index = bits.getBits(4);
    bits.skipBits(1);   // b_iframe_global

    int32_t n_presentations = 0;
    int32_t no_of_presentations = bits.getBits(1); // b_single_presentation

    if (no_of_presentations == 1) {
        n_presentations = 1;
    } else {
        int32_t b_more_presentations = bits.getBits(1); // b_more_presentations
        if (b_more_presentations == 1) {
            n_presentations = readVariableBits(bits, 2) + 2;
        } else {
            n_presentations = 0;
        }
    }

    int32_t b_payload_base = bits.getBits(1);       // b_payload_base
    if (b_payload_base) {
        int32_t payload_base_minus1 = bits.getBits(5);
        int32_t payload_base = payload_base_minus1 + 1;
        if (payload_base == 0x20) {
            payload_base += readVariableBits(bits, 3);
        }
    }

    int32_t channel_count = -1;
    if (bitstream_version <= 1) {
        for (int32_t i = 0; i < n_presentations; i++) {
            result = parseAc4PresentationInfo(bits, channel_count, frame_rate_index);
            if (result < 0) {
                return result;
            } else {
                *chanCount = channel_count;
                if (*chanCount > 0) {
                    return result;
                }
            }
        }
    } else {
        int32_t b_program_id = bits.getBits(1);
        if (b_program_id) {
            bits.skipBits(16); // short_program_id
            int32_t b_program_uuid_present = bits.getBits(1);
            if (b_program_uuid_present) {
                bits.skipBits(16*8);
            }
        }
        for (int32_t i = 0; i < n_presentations; i++) {
            result = parseAc4PresentationV1Info(bits, channel_count,
                    bitstream_version, frame_rate_index);
            if (result < 0) {
                return result;
            } else {
                *chanCount = channel_count;
                if (*chanCount > 0) {
                    return result;
                }
            }
        }
        int32_t total_n_substream_groups = 1;       // TODO
        for (int32_t j = 0; j < total_n_substream_groups; j++) {
            result = parseAc4SubstreamGroupInfo(bits, channel_count, bitstream_version);
            if (result < 0) {
                return result;
            } else {
                *chanCount = channel_count;
                if (*chanCount > 0) {
                    return result;
                }
            }
        }
    }
    // Ignore substream_index_table();
    // Ignore "byte_align" (0~7)

    return result;
}

static int32_t mapDsiPresentationChModeToChannels(int32_t pres_ch_mode) {
// ETSI TS 103 190-2 V1.1.1 (2015-09), Table 79
    int32_t channel_count = -1;

    switch (pres_ch_mode) {
        case 0:  channel_count = 1; break;  /* mono */
        case 1:  channel_count = 2; break;  /* stereo or IMS */
        case 2:  channel_count = 3; break;  /* 3.0 */
        case 3:  channel_count = 5; break;  /* 5.0 */
        case 4:  channel_count = 6; break;  /* 5.1 */
        case 5:  channel_count = 7; break;  /* 7.0 */
        case 6:  channel_count = 8; break;  /* 7.1 */
        case 7:  channel_count = 7; break;  /* 7.0 */
        case 8:  channel_count = 8; break;  /* 7.1 */
        case 9:  channel_count = 7; break;  /* 7.0 */
        case 10: channel_count = 8; break;  /* 7.1 */
        case 11: channel_count = 11; break; /* 7.0.4 */
        case 12: channel_count = 12; break; /* 7.1.4 */
        case 13: channel_count = 13; break; /* 9.0.4 */
        case 14: channel_count = 14; break; /* 9.1.4 */
        case 15: channel_count = 24; break; /* 22.2 */
        default:
            ALOGE("AC4Parsing...Incorrect channel number !!!");
            break;
    }
    return channel_count;
}

static void parsePresentationV0Dsi() {
    // This case can be ignored.
    // For bitstream version 2, presentation version is NOT zero.
}

static void parsePresentationV1Dsi(ABitReader &bits, int32_t &chanCount) {

    int32_t b_add_emdf_substreams = 0;
    int32_t presentation_config_v1 = bits.getBits(5);
    if (presentation_config_v1 == 0x06) {
        b_add_emdf_substreams = 1;
    } else {
        bits.skipBits(3);            // mdcompat
        if (bits.getBits(1)) {       // b_presentation_group_index
            bits.skipBits(5);        // presentation_group_index
        }
        bits.skipBits(2);   // dsi_frame_rate_multiply_info
        bits.skipBits(2);   // dsi_frame_rate_fraction_info
        bits.skipBits(5);   // presentation_emdf_version
        bits.skipBits(10);  // presentation_key_id
        int32_t b_presentation_channel_coded = bits.getBits(1);
        if (b_presentation_channel_coded) {
            int32_t dsi_presentation_ch_mode = bits.getBits(5);
            chanCount = mapDsiPresentationChModeToChannels(dsi_presentation_ch_mode);
        } else {
            ALOGE("It is NOT supported by now, as it deals with OAMD and JOC!!!");
        }
    }
}

static void parseAc4DsiV1(ABitReader &bits, int32_t &chanCount, int32_t &smplRate) {

    int32_t bitstream_version = 0;
    int32_t bit_align_count = 0;

    if (bits.getBits(3) != 1) { // ac4_dsi_version - only 001 is supported
        ALOGE("ac4_dsi_version is not equal to 001!!!");
        return;
    }
    bit_align_count += 3;

    bitstream_version = bits.getBits(7);
    bit_align_count += 7;

    int32_t fs_index = bits.getBits(1);
    bit_align_count += 1;

    if (fs_index == 0) {
        smplRate = 44100;
    } else {
        smplRate = 48000;
    }

    bits.skipBits(4);   // frame_rate_index
    bit_align_count += 4;

    int32_t n_presentations = bits.getBits(9);
    bit_align_count += 9;

    if (bitstream_version > 1) {
        int32_t b_program_id = bits.getBits(1);
        bit_align_count += 1;

        if (b_program_id) {
            bits.skipBits(16);  // short_program_id
            bit_align_count += 16;
            if (bits.getBits(1)) {  // b_uuid
                int32_t sub_total = 16 * 8;
                bits.skipBits(sub_total);   // program_uuid
                bit_align_count += (sub_total);
            }
            bit_align_count += 1;
        }
    }

    bits.skipBits(66);  // ac4_bitrate_dsi() (2+32+32)
    bit_align_count += 66;

    int32_t no_of_bits_to_align = bit_align_count % 8;

    if (no_of_bits_to_align != 0) {
        bits.skipBits(8 - no_of_bits_to_align);
    }

    for (int32_t i = 0; i < n_presentations; i++) {
        int32_t presentation_version = bits.getBits(8);
        int32_t pres_bytes           = bits.getBits(8);

        if (pres_bytes == 255) {
            int32_t add_pres_bytes = bits.getBits(16);
            pres_bytes += add_pres_bytes;
        }

        if (presentation_version == 0) {
            parsePresentationV0Dsi();
            if( chanCount > 0 )
                return;
        } else {
            if (presentation_version == 1 || presentation_version == 2) {
                parsePresentationV1Dsi(bits, chanCount);
                if( chanCount > 0 )
                    return;
            }
        }
    }
}

int32_t parseAc4BoxInfo(const uint8_t *ptr, size_t size, int32_t *chanCount, int32_t *smplRate) {

    int32_t result = -1;
    int32_t channel_count = -1;
    int32_t sample_rate = 0;

    ALOGV("Inside parseAc4BoxInfo");
    ABitReader bits(ptr, size);
    parseAc4DsiV1(bits, channel_count, sample_rate); // ac4_dsi_version 001 is supported

    if (channel_count > 0) {
        result = 0;
        *chanCount = channel_count;
    }

    *smplRate  = sample_rate;
    return result;
}

}  // namespace android

